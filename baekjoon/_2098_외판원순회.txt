4
0 10 15 20
5 0 9 10
6 13 0 12
8 8 9 0


// 1 ~ n번의 도시
// 어느 한 도시에서 출발, 모든 도시 순회
// 단, 한번 방문한곳은 다시 갈 수 없다.
// 최소비용은?


dp[i][j]는 i->j의 최소비용

dp = {
    {0,10, 15}
}

그냥 dfs 완전탐색하면서 dp 항상 체크하면 될듯

dp[0][0] = 0
dp[0][1] = 10
    s=0, e=1인 dfs 시작
    e==1인 경로들의 합 중 최솟값
        0,1:
            dp[0][1] 체크
            10 = 10(min)
        0,2,1:
            dp[0][2] 체크
            dp[0][1] 체크
            15+13 = 28
        0,2,3,1: 15+12+8 = 35
dp[0][2] =
    s=0, e=2인 dfs 시작
    e==2인 경로들의 합 중 최솟값
        0,2: 15
        0,1,2: 10+
